{% extends "base.html" %}

{% block content %}
<nav class="production-nav" aria-label="Production pages">
    <a href="{{ url_for('production.daily_entry') }}" class="production-nav-link">Daily Entry</a>
    <a href="{{ url_for('production.history') }}" class="production-nav-link is-active">History</a>
    <a href="{{ url_for('production.production_settings') }}" class="production-nav-link">Settings</a>
</nav>

<h2>Production History</h2>
<p class="section-help">Select a date range to review production totals, customer breakdowns, and month-to-date trends.</p>
{% if grouped_customer_names %}
    <p class="chart-note">Customers grouped into the <strong>Other</strong> series: {{ grouped_customer_names | join(', ') }}.</p>
{% endif %}


<form method="get" class="date-range-form">
    <div class="form-field">
        <label for="start_date" class="field-label">Start Date</label>
        <input type="date" id="start_date" name="start_date" value="{{ start_date.isoformat() }}">
    </div>
    <div class="form-field">
        <label for="end_date" class="field-label">End Date</label>
        <input type="date" id="end_date" name="end_date" value="{{ end_date.isoformat() }}">
    </div>
    <div class="form-actions">
        <button type="submit">Update Range</button>
    </div>
</form>

{% if not chart_labels %}
    <p class="chart-empty">No production records were found for the selected dates.</p>
{% else %}
    <section class="dashboard-section">
        <h3>Visual Breakdown</h3>
        <div class="chart-controls">
            <label class="chart-toggle" for="collapseWeekendsToggle">
                <input type="checkbox" id="collapseWeekendsToggle" name="collapse_weekends">
                Collapse weekends
            </label>
            <button type="button" class="action-btn chart-export-button" id="emailDataButton" {% if not chart_labels %}disabled{% endif %}>
                Email Data
            </button>
        </div>
        <div class="chart-grid">
            <div class="chart-card">
                <canvas id="gatesProducedChart" aria-label="Stacked column chart showing gates produced per customer"></canvas>
            </div>
            <div class="chart-card">
                <canvas id="cumulativeChart" aria-label="Line chart showing cumulative month-to-date production totals"></canvas>
            </div>
            {% if chart_visibility.show_shift_chart %}
            <div class="chart-card">
                <canvas id="shiftChart" aria-label="Bar chart showing production by shift" hidden></canvas>
                <p class="chart-empty" data-chart-empty-for="shiftChart">No shift production data available for the selected range.</p>
            </div>
            {% endif %}
            {% if chart_visibility.show_product_type_chart %}
            <div class="chart-card">
                <canvas id="productTypeChart" aria-label="Horizontal bar chart showing production by product type" hidden></canvas>
                <p class="chart-empty" data-chart-empty-for="productTypeChart">No production by product type data available for the selected range.</p>
            </div>
            {% endif %}
            {% if chart_visibility.show_scrap_chart %}
            <div class="chart-card">
                <canvas id="scrapChart" aria-label="Line chart showing scrap and rejects over time" hidden></canvas>
                <p class="chart-empty" data-chart-empty-for="scrapChart">No scrap or reject data available for the selected range.</p>
            </div>
            {% endif %}
            {% if chart_visibility.show_downtime_chart %}
            <div class="chart-card">
                <canvas id="downtimeChart" aria-label="Pareto chart of downtime causes" hidden></canvas>
                <p class="chart-empty" data-chart-empty-for="downtimeChart">No downtime information recorded for the selected range.</p>
            </div>
            {% endif %}
            {% if chart_visibility.show_cumulative_goal_chart %}
            <div class="chart-card">
                <canvas id="cumulativeGoalChart" aria-label="Line chart comparing cumulative production against goal" hidden></canvas>
                <p class="chart-empty" data-chart-empty-for="cumulativeGoalChart">No goal comparison data available for the selected range.</p>
            </div>
            {% endif %}
        </div>
    </section>

    <section class="dashboard-section">
        <div class="section-header">
            <h3>Custom Graph Builder</h3>
        </div>
        <p class="section-help">Use the configurable controls to build ad-hoc production charts by combining dimensions and metrics of interest.</p>
        <form class="form-grid custom-builder-controls" id="customBuilderControls" aria-label="Custom graph builder controls">
            <div class="form-field">
                <label for="builderDimensionSelect" class="field-label">Primary Dimension</label>
                <select id="builderDimensionSelect" name="builder_dimension">
                    <option value="" {% if not custom_builder_defaults.get('dimension') %}selected{% endif %}>Date</option>
                    <option value="customer" {% if custom_builder_defaults.get('dimension') == 'customer' %}selected{% endif %}>Customer</option>
                    <option value="product_type" {% if custom_builder_defaults.get('dimension') == 'product_type' %}selected{% endif %}>Product Type</option>
                    <option value="shift" {% if custom_builder_defaults.get('dimension') == 'shift' %}selected{% endif %}>Shift</option>
                    <option value="downtime_cause" {% if custom_builder_defaults.get('dimension') == 'downtime_cause' %}selected{% endif %}>Downtime Cause</option>
                    <option value="day_of_week" {% if custom_builder_defaults.get('dimension') == 'day_of_week' %}selected{% endif %}>Day of Week</option>
                    <option value="month" {% if custom_builder_defaults.get('dimension') == 'month' %}selected{% endif %}>Month</option>
                    <option value="week" {% if custom_builder_defaults.get('dimension') == 'week' %}selected{% endif %}>Week</option>
                </select>
            </div>
            <div class="form-field">
                <label for="builderSeriesSelect" class="field-label">Breakdown Series</label>
                <select id="builderSeriesSelect" name="builder_series">
                    <option value="" {% if not custom_builder_defaults.get('series') %}selected{% endif %}>None</option>
                    <option value="customer" {% if custom_builder_defaults.get('series') == 'customer' %}selected{% endif %}>Customer</option>
                    <option value="product_type" {% if custom_builder_defaults.get('series') == 'product_type' %}selected{% endif %}>Product Type</option>
                    <option value="shift" {% if custom_builder_defaults.get('series') == 'shift' %}selected{% endif %}>Shift</option>
                    <option value="downtime_cause" {% if custom_builder_defaults.get('series') == 'downtime_cause' %}selected{% endif %}>Downtime Cause</option>
                    <option value="day_of_week" {% if custom_builder_defaults.get('series') == 'day_of_week' %}selected{% endif %}>Day of Week</option>
                    <option value="month" {% if custom_builder_defaults.get('series') == 'month' %}selected{% endif %}>Month</option>
                    <option value="week" {% if custom_builder_defaults.get('series') == 'week' %}selected{% endif %}>Week</option>
                </select>
            </div>
            <div class="form-field">
                <label for="builderMetricSelect" class="field-label">Metric</label>
                <select id="builderMetricSelect" name="builder_metric">
                    <option value="gates_produced" {% if custom_builder_defaults.get('metric') == 'gates_produced' or not custom_builder_defaults.get('metric') %}selected{% endif %}>Gates Produced</option>
                    <option value="gates_packaged" {% if custom_builder_defaults.get('metric') == 'gates_packaged' %}selected{% endif %}>Gates Packaged</option>
                    <option value="scrap" {% if custom_builder_defaults.get('metric') == 'scrap' %}selected{% endif %}>Scrap / Rejects</option>
                    <option value="runtime_hours" {% if custom_builder_defaults.get('metric') == 'runtime_hours' %}selected{% endif %}>Runtime Hours</option>
                    <option value="overtime_hours" {% if custom_builder_defaults.get('metric') == 'overtime_hours' %}selected{% endif %}>Overtime Hours</option>
                    <option value="produced_per_hour" {% if custom_builder_defaults.get('metric') == 'produced_per_hour' %}selected{% endif %}>Produced per Hour</option>
                    <option value="efficiency" {% if custom_builder_defaults.get('metric') == 'efficiency' %}selected{% endif %}>Efficiency</option>
                    <option value="goal" {% if custom_builder_defaults.get('metric') == 'goal' %}selected{% endif %}>Goal</option>
                    <option value="goal_gap" {% if custom_builder_defaults.get('metric') == 'goal_gap' %}selected{% endif %}>Goal Gap</option>
                </select>
            </div>
            <div class="form-field">
                <label for="builderAggregationSelect" class="field-label">Aggregation</label>
                <select id="builderAggregationSelect" name="builder_aggregation">
                    <option value="sum" {% if custom_builder_defaults.get('aggregation') == 'sum' or not custom_builder_defaults.get('aggregation') %}selected{% endif %}>Sum</option>
                    <option value="average" {% if custom_builder_defaults.get('aggregation') == 'average' %}selected{% endif %}>Average</option>
                </select>
            </div>
            <div class="form-field">
                <label for="builderChartTypeSelect" class="field-label">Chart Type</label>
                <select id="builderChartTypeSelect" name="builder_chart_type">
                    <option value="bar" {% if custom_builder_defaults.get('chart_type') == 'bar' or not custom_builder_defaults.get('chart_type') %}selected{% endif %}>Bar</option>
                    <option value="line" {% if custom_builder_defaults.get('chart_type') == 'line' %}selected{% endif %}>Line</option>
                    <option value="stacked" {% if custom_builder_defaults.get('chart_type') == 'stacked' %}selected{% endif %}>Stacked Bar</option>
                </select>
            </div>
            <div class="form-field">
                <label class="field-label" for="builderResetButton">&nbsp;</label>
                <button type="button" class="action-btn" id="builderResetButton">Reset to Defaults</button>
            </div>
        </form>
        <div class="chart-card custom-builder-card">
            <canvas id="customBuilderChart" aria-label="Custom graph builder chart" hidden></canvas>
            <p class="chart-empty" data-chart-empty-for="customBuilderChart">Select a combination of dimensions and metrics to build a chart.</p>
        </div>
        <p class="chart-note" id="customBuilderSummary"></p>
    </section>

    <div class="chart-modal is-hidden" id="chartModal" role="dialog" aria-modal="true" aria-label="Expanded chart view">
        <div class="chart-modal-dialog">
            <button type="button" class="chart-modal-close" data-modal-dismiss aria-label="Close expanded chart">&times;</button>
            <canvas id="expandedChart" aria-label="Expanded chart canvas"></canvas>
        </div>
    </div>

    <div class="email-modal is-hidden" id="emailDataModal" role="dialog" aria-modal="true" aria-labelledby="emailDataTitle">
        <div class="email-modal-dialog" tabindex="-1">
            <button type="button" class="email-modal-close" data-email-dismiss aria-label="Close email data preview">&times;</button>
            <div class="email-modal-header">
                <h3 id="emailDataTitle">Email Data Preview</h3>
                <p id="emailDataSubtitle" class="email-modal-subtitle"></p>
            </div>
            <div class="email-modal-note" id="emailDataNote"></div>
            <div class="email-modal-actions">
                <button type="button" class="action-btn email-modal-copy-button" id="copyEmailNoteButton">Copy Notes</button>
            </div>
            <div class="email-modal-gallery">
                <figure>
                    <img id="emailDataBarImage" alt="Gates produced chart preview">
                    <figcaption>Gates Produced by Customer</figcaption>
                </figure>
                <figure>
                    <img id="emailDataLineImage" alt="Cumulative production chart preview">
                    <figcaption>Cumulative Production Totals</figcaption>
                </figure>
            </div>
            <p class="email-modal-hint">Right-click an image to copy it into your email message.</p>
        </div>
    </div>

    <section class="dashboard-section">
        <div class="section-header">
            <h3>Daily Detail</h3>
            <button type="button" class="action-btn" id="dailyDetailToggle" data-show-text="Show Daily Detail" data-hide-text="Hide Daily Detail" aria-expanded="false" aria-controls="dailyDetailContainer">
                Show Daily Detail
            </button>
        </div>
        <p class="section-help">Labor hours assume an 8-hour base shift per employee plus the overtime entered for each section.</p>
        <div class="table-scroll" id="dailyDetailContainer" hidden>
            <table class="inventory-table production-history-table">
                <thead>
                    <tr>
                        <th scope="col" class="sortable-header" aria-sort="none">Date</th>
                        <th scope="col" class="sortable-header" aria-sort="none">Day</th>
                        <th scope="col" class="sortable-header" aria-sort="none">Gates Produced</th>
                        <th scope="col" class="sortable-header" aria-sort="none">Gates Packaged</th>
                        <th scope="col" class="sortable-header" aria-sort="none">Gates Labor<br><small>Employees / OT / Hours</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Output per Labor Hour<br><small>Gates Combined</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Controllers<br><small>4 Stop / 6 Stop</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Door Locks<br><small>LH / RH</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Operators</th>
                        <th scope="col" class="sortable-header" aria-sort="none">COPs</th>
                        <th scope="col" class="sortable-header" aria-sort="none">Additional Labor<br><small>Employees / OT / Hours</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Additional Output<br><small>Units per Labor Hour</small></th>
                        <th scope="col" class="sortable-header" aria-sort="none">Notes</th>
                    </tr>
                </thead>
                <tbody>
                    {% for row in table_rows %}
                        <tr>
                            <td data-sort-value="{{ row.record.entry_date.strftime('%Y-%m-%d') }}">{{ row.record.entry_date.strftime('%Y-%m-%d') }}</td>
                            <td data-sort-value="{{ row.record.day_of_week }}">{{ row.record.day_of_week }}</td>
                            <td data-sort-value="{{ row.produced_sum }}">
                                <strong>{{ row.produced_sum }}</strong>
                                <div class="totals-breakdown">
                                    {% for customer in customers %}
                                        <span>{{ customer.name }}: {{ row.per_customer_produced.get(customer.id, 0) }}</span>

                                    {% endfor %}
                                </div>
                            </td>
                            <td data-sort-value="{{ row.packaged_sum }}">
                                <strong>{{ row.packaged_sum }}</strong>
                                <div class="totals-breakdown">
                                    {% for customer in customers %}
                                        <span>{{ customer.name }}: {{ row.per_customer_packaged.get(customer.id, 0) }}</span>

                                    {% endfor %}
                                </div>
                            </td>
                            <td data-sort-value="{{ row.gates_total_hours_value }}">
                                <div class="totals-breakdown">
                                    <span>Employees: {{ row.gates_employees }}</span>
                                    <span>OT Hours: {{ row.gates_hours_ot }}</span>
                                    <span>Total Hours: {{ row.gates_total_hours }}</span>
                                </div>
                            </td>
                            <td data-sort-value="{{ row.output_per_hour_value if row.output_per_hour_value is not none else 0 }}">
                                {% if row.gates_output_per_hour %}
                                    <strong>{{ row.gates_output_per_hour }}</strong>
                                {% endif %}
                                {% if row.output_variables %}
                                    <div class="totals-breakdown">
                                        {% for metric in row.output_variables %}
                                            <span>{{ metric.label }}: {{ metric.value }}</span>
                                        {% endfor %}
                                    </div>
                                {% elif not row.gates_output_per_hour %}
                                    —
                                {% endif %}
                            </td>
                            <td data-sort-value="{{ row.controllers_total }}">
                                <div class="metric-pair">
                                    <span>{{ row.record.controllers_4_stop }}</span>
                                    <span>{{ row.record.controllers_6_stop }}</span>
                                </div>
                            </td>
                            <td data-sort-value="{{ row.door_locks_total }}">
                                <div class="metric-pair">
                                    <span>{{ row.record.door_locks_lh }}</span>
                                    <span>{{ row.record.door_locks_rh }}</span>
                                </div>
                            </td>
                            <td data-sort-value="{{ row.operators_total }}">{{ row.operators_total }}</td>
                            <td data-sort-value="{{ row.cops_total }}">{{ row.cops_total }}</td>
                            <td data-sort-value="{{ row.additional_total_hours_value }}">
                                <div class="totals-breakdown">
                                    <span>Employees: {{ row.additional_employees }}</span>
                                    <span>OT Hours: {{ row.additional_hours_ot }}</span>
                                    <span>Total Hours: {{ row.additional_total_hours }}</span>
                                </div>
                            </td>
                            <td data-sort-value="{{ row.additional_output_total_value }}">
                                {% if row.additional_per_hour %}
                                    <div class="totals-breakdown">
                                        {% for metric in row.additional_per_hour %}
                                            <span>{{ metric.label }}: {{ metric.per_hour }}</span>
                                        {% endfor %}
                                    </div>
                                {% else %}
                                    —
                                {% endif %}
                            </td>
                            <td data-sort-value="{{ row.record.daily_notes or '' }}">{{ row.record.daily_notes or '—' }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </section>
{% endif %}
{% endblock %}

{% block extra_scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const chartLabels = {{ chart_labels|tojson }};
    const stackedDatasets = {{ stacked_datasets|tojson }};
    const overlayDatasets = {{ overlay_datasets|tojson }};
    const lineDatasets = {{ line_datasets|tojson }};
    const chartAxisSettings = {{ chart_axis_settings|tojson }};
    const emailPreview = {{ email_preview|tojson }};
    const chartVisibility = {{ chart_visibility|tojson }};
    const customBuilderRows = {{ custom_builder_rows|tojson }};
    const customBuilderDefaults = {{ custom_builder_defaults|tojson }};

    const parseDateLabel = (label) => {
        if (typeof label !== 'string') {
            return null;
        }
        const parts = label.split('-').map((value) => Number.parseInt(value, 10));
        if (parts.length !== 3 || parts.some((value) => Number.isNaN(value))) {
            return null;
        }
        const [year, month, day] = parts;
        return new Date(Date.UTC(year, month - 1, day));
    };

    const isWeekendLabel = (label) => {
        const parsedDate = parseDateLabel(label);
        if (!parsedDate) {
            return false;
        }
        const dayOfWeek = parsedDate.getUTCDay();
        return dayOfWeek === 0 || dayOfWeek === 6;
    };

    const toggleChartFallback = (canvasId, hasData) => {
        const canvas = document.getElementById(canvasId);
        const fallback = document.querySelector(`[data-chart-empty-for="${canvasId}"]`);
        if (canvas) {
            canvas.hidden = !hasData;
        }
        if (fallback) {
            fallback.hidden = hasData;
        }
    };

    const chartColorPalette = [
        '#2563eb',
        '#f97316',
        '#16a34a',
        '#8b5cf6',
        '#ec4899',
        '#14b8a6',
        '#facc15',
    ];

    const shiftColorMap = {
        'Day Shift': '#0ea5e9',
        'Night Shift': '#6366f1',
        Unspecified: '#3b82f6',
    };

    const dimensionAccessors = {
        date: (row) => row.date_display || row.date,
        customer: (row) => row.customer,
        product_type: (row) => row.product_type,
        shift: (row) => row.shift,
        downtime_cause: (row) => row.downtime_cause,
        day_of_week: (row) => row.day_of_week,
        month: (row) => row.month,
        week: (row) => row.week,
    };

    const fallbackDimensionValue = 'Unspecified';

    const getDimensionValue = (row, key) => {
        if (!row) {
            return fallbackDimensionValue;
        }
        const accessor = dimensionAccessors[key] || ((entry) => entry?.[key]);
        const value = accessor(row);
        if (value === undefined || value === null || value === '') {
            return fallbackDimensionValue;
        }
        return String(value);
    };

    const buildShiftAggregate = (rows) => {
        if (!Array.isArray(rows) || !rows.length) {
            return { labels: [], data: [], colors: [] };
        }
        const totals = new Map();
        rows.forEach((row) => {
            const produced = Number(row?.metrics?.gates_produced ?? 0);
            if (!Number.isFinite(produced) || produced === 0) {
                return;
            }
            const label = row.shift || fallbackDimensionValue;
            totals.set(label, (totals.get(label) || 0) + produced);
        });
        const labels = [];
        const data = [];
        const colors = [];
        totals.forEach((value, label) => {
            if (!value) {
                return;
            }
            labels.push(label);
            data.push(Number(value.toFixed(2)));
            colors.push(shiftColorMap[label] || '#3b82f6');
        });
        return { labels, data, colors };
    };

    const buildProductAggregate = (rows) => {
        if (!Array.isArray(rows) || !rows.length) {
            return { labels: [], data: [], colors: [] };
        }
        const totals = new Map();
        rows.forEach((row) => {
            const produced = Number(row?.metrics?.gates_produced ?? 0);
            if (!Number.isFinite(produced) || produced === 0) {
                return;
            }
            const label = row.product_type || fallbackDimensionValue;
            totals.set(label, (totals.get(label) || 0) + produced);
        });
        const sorted = Array.from(totals.entries()).filter(([, value]) => value).sort((a, b) => b[1] - a[1]);
        const labels = sorted.map((entry) => entry[0]);
        const data = sorted.map((entry) => Number(entry[1].toFixed(2)));
        const colorLookup = new Map();
        if (Array.isArray(stackedDatasets)) {
            stackedDatasets.forEach((dataset) => {
                if (dataset?.label) {
                    colorLookup.set(dataset.label, dataset.backgroundColor || '#3b82f6');
                }
            });
        }
        const colors = labels.map((label) => colorLookup.get(label) || '#3b82f6');
        return { labels, data, colors };
    };

    const buildScrapAggregate = (rows) => {
        if (!Array.isArray(rows) || !rows.length) {
            return { labels: [], produced: [], scrap: [] };
        }
        const dailyTotals = new Map();
        rows.forEach((row) => {
            const date = row.date || row.date_display;
            if (!date) {
                return;
            }
            const produced = Number(row?.metrics?.gates_produced ?? 0);
            const scrap = Number(row?.metrics?.scrap ?? 0);
            if (!dailyTotals.has(date)) {
                dailyTotals.set(date, { produced: 0, scrap: 0 });
            }
            const entry = dailyTotals.get(date);
            if (Number.isFinite(produced)) {
                entry.produced += produced;
            }
            if (Number.isFinite(scrap)) {
                entry.scrap += scrap;
            }
        });
        const labels = Array.from(dailyTotals.keys()).sort();
        const producedSeries = labels.map((label) => Number(dailyTotals.get(label).produced.toFixed(2)));
        const scrapSeries = labels.map((label) => Number(dailyTotals.get(label).scrap.toFixed(2)));
        return { labels, produced: producedSeries, scrap: scrapSeries };
    };

    const buildDowntimeAggregate = (rows) => {
        if (!Array.isArray(rows) || !rows.length) {
            return { labels: [], impact: [], cumulative: [] };
        }
        const totals = new Map();
        rows.forEach((row) => {
            const rawGap = row?.metrics?.goal_gap;
            const rawHours = row?.metrics?.overtime_hours;
            let impact = 0;
            if (Number.isFinite(rawGap)) {
                impact = Math.max(Number(rawGap), 0);
            } else if (Number.isFinite(rawHours)) {
                impact = Math.max(Number(rawHours), 0);
            }
            if (!impact) {
                return;
            }
            const cause = row.downtime_cause || fallbackDimensionValue;
            totals.set(cause, (totals.get(cause) || 0) + impact);
        });
        const sorted = Array.from(totals.entries()).filter(([, value]) => value).sort((a, b) => b[1] - a[1]);
        const labels = sorted.map((entry) => entry[0]);
        const impact = sorted.map((entry) => Number(entry[1].toFixed(2)));
        const totalImpact = impact.reduce((sum, value) => sum + value, 0);
        const cumulative = [];
        let running = 0;
        impact.forEach((value) => {
            running += value;
            cumulative.push(totalImpact ? Number(((running / totalImpact) * 100).toFixed(2)) : 0);
        });
        return { labels, impact, cumulative };
    };

    const buildCumulativeGoalAggregate = (rows) => {
        if (!Array.isArray(rows) || !rows.length) {
            return { labels: [], produced: [], goal: [] };
        }
        const dailyTotals = new Map();
        rows.forEach((row) => {
            const date = row.date || row.date_display;
            if (!date) {
                return;
            }
            const produced = Number(row?.metrics?.gates_produced ?? 0);
            const goal = Number(row?.metrics?.goal ?? 0);
            if (!dailyTotals.has(date)) {
                dailyTotals.set(date, { produced: 0, goal: 0 });
            }
            const entry = dailyTotals.get(date);
            if (Number.isFinite(produced)) {
                entry.produced += produced;
            }
            if (Number.isFinite(goal)) {
                entry.goal += goal;
            }
        });
        const labels = Array.from(dailyTotals.keys()).sort();
        const producedSeries = [];
        const goalSeries = [];
        let producedRunning = 0;
        let goalRunning = 0;
        labels.forEach((label) => {
            const entry = dailyTotals.get(label);
            producedRunning += entry.produced;
            goalRunning += entry.goal;
            producedSeries.push(Number(producedRunning.toFixed(2)));
            goalSeries.push(Number(goalRunning.toFixed(2)));
        });
        return { labels, produced: producedSeries, goal: goalSeries };
    };

    const filterRowsForWeekends = (includeWeekends) => {
        if (!Array.isArray(customBuilderRows)) {
            return [];
        }
        if (includeWeekends) {
            return customBuilderRows.slice();
        }
        return customBuilderRows.filter((row) => !isWeekendLabel(row.date));
    };

    let shiftChart = null;
    let productTypeChart = null;
    let scrapChart = null;
    let downtimeChart = null;
    let cumulativeGoalChart = null;
    let customBuilderChart = null;
    let activeBuilderRows = filterRowsForWeekends(true);

    const registerExpandableChart = (canvasElement, chartInstance) => {
        if (!canvasElement || !chartInstance) {
            return;
        }
        if (
            typeof window !== 'undefined' &&
            typeof window.__registerChartExpansion === 'function'
        ) {
            window.__registerChartExpansion(canvasElement, chartInstance);
        }
    };

    const ensureShiftChart = (aggregate) => {
        if (!chartVisibility?.show_shift_chart) {
            return;
        }
        const canvasId = 'shiftChart';
        const hasData = aggregate && Array.isArray(aggregate.labels) && aggregate.labels.length > 0;
        if (!hasData) {
            toggleChartFallback(canvasId, false);
            if (shiftChart) {
                shiftChart.destroy();
                shiftChart = null;
            }
            return;
        }
        toggleChartFallback(canvasId, true);
        const data = {
            labels: aggregate.labels,
            datasets: [
                {
                    label: 'Gates Produced',
                    data: aggregate.data,
                    backgroundColor: aggregate.colors,
                },
            ],
        };
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: 'Production by Shift' },
                legend: { display: false },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Gates Produced' },
                },
            },
        };
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }
        if (shiftChart) {
            shiftChart.data = data;
            shiftChart.options = options;
            shiftChart.update();
            return;
        }
        shiftChart = new Chart(canvas, { type: 'bar', data, options });
        registerExpandableChart(canvas, shiftChart);
    };

    const ensureProductTypeChart = (aggregate) => {
        if (!chartVisibility?.show_product_type_chart) {
            return;
        }
        const canvasId = 'productTypeChart';
        const hasData = aggregate && Array.isArray(aggregate.labels) && aggregate.labels.length > 0;
        if (!hasData) {
            toggleChartFallback(canvasId, false);
            if (productTypeChart) {
                productTypeChart.destroy();
                productTypeChart = null;
            }
            return;
        }
        toggleChartFallback(canvasId, true);
        const data = {
            labels: aggregate.labels,
            datasets: [
                {
                    label: 'Gates Produced',
                    data: aggregate.data,
                    backgroundColor: aggregate.colors,
                },
            ],
        };
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
                title: { display: true, text: 'Production by Product Type' },
                legend: { display: false },
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Gates Produced' },
                },
            },
        };
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }
        if (productTypeChart) {
            productTypeChart.data = data;
            productTypeChart.options = options;
            productTypeChart.update();
            return;
        }
        productTypeChart = new Chart(canvas, { type: 'bar', data, options });
        registerExpandableChart(canvas, productTypeChart);
    };

    const ensureScrapChart = (aggregate) => {
        if (!chartVisibility?.show_scrap_chart) {
            return;
        }
        const canvasId = 'scrapChart';
        const hasData =
            aggregate && Array.isArray(aggregate.labels) && aggregate.labels.length > 0;
        if (!hasData) {
            toggleChartFallback(canvasId, false);
            if (scrapChart) {
                scrapChart.destroy();
                scrapChart = null;
            }
            return;
        }
        toggleChartFallback(canvasId, true);
        const data = {
            labels: aggregate.labels,
            datasets: [
                {
                    label: 'Total Produced',
                    data: aggregate.produced,
                    borderColor: '#2563eb',
                    backgroundColor: 'rgba(37, 99, 235, 0.2)',
                    fill: false,
                    tension: 0.25,
                },
                {
                    label: 'Scrap / Rejects',
                    data: aggregate.scrap,
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.2)',
                    fill: false,
                    tension: 0.25,
                },
            ],
        };
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: 'Scrap and Rejects Over Time' },
                legend: { position: 'bottom' },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Units' },
                },
            },
        };
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }
        if (scrapChart) {
            scrapChart.data = data;
            scrapChart.options = options;
            scrapChart.update();
            return;
        }
        scrapChart = new Chart(canvas, { type: 'line', data, options });
        registerExpandableChart(canvas, scrapChart);
    };

    const ensureDowntimeChart = (aggregate) => {
        if (!chartVisibility?.show_downtime_chart) {
            return;
        }
        const canvasId = 'downtimeChart';
        const hasData =
            aggregate && Array.isArray(aggregate.labels) && aggregate.labels.length > 0;
        if (!hasData) {
            toggleChartFallback(canvasId, false);
            if (downtimeChart) {
                downtimeChart.destroy();
                downtimeChart = null;
            }
            return;
        }
        toggleChartFallback(canvasId, true);
        const data = {
            labels: aggregate.labels,
            datasets: [
                {
                    type: 'bar',
                    label: 'Impact (units)',
                    data: aggregate.impact,
                    backgroundColor: 'rgba(249, 115, 22, 0.6)',
                    borderColor: '#f97316',
                    yAxisID: 'y',
                },
                {
                    type: 'line',
                    label: 'Cumulative %',
                    data: aggregate.cumulative,
                    borderColor: '#2563eb',
                    backgroundColor: 'rgba(37, 99, 235, 0.15)',
                    yAxisID: 'y-percentage',
                    fill: false,
                    tension: 0.2,
                    pointRadius: 3,
                },
            ],
        };
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: 'Downtime Cause Analysis' },
                legend: { position: 'bottom' },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Impact (units)' },
                },
                'y-percentage': {
                    beginAtZero: true,
                    suggestedMax: 100,
                    position: 'right',
                    grid: { drawOnChartArea: false },
                    ticks: {
                        callback: (value) => `${value}%`,
                    },
                    title: { display: true, text: 'Cumulative %' },
                },
            },
        };
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }
        if (downtimeChart) {
            downtimeChart.data = data;
            downtimeChart.options = options;
            downtimeChart.update();
            return;
        }
        downtimeChart = new Chart(canvas, { data, options });
        registerExpandableChart(canvas, downtimeChart);
    };

    const ensureCumulativeGoalChart = (aggregate) => {
        if (!chartVisibility?.show_cumulative_goal_chart) {
            return;
        }
        const canvasId = 'cumulativeGoalChart';
        const hasData =
            aggregate && Array.isArray(aggregate.labels) && aggregate.labels.length > 0;
        if (!hasData) {
            toggleChartFallback(canvasId, false);
            if (cumulativeGoalChart) {
                cumulativeGoalChart.destroy();
                cumulativeGoalChart = null;
            }
            return;
        }
        toggleChartFallback(canvasId, true);
        const datasets = [
            {
                label: 'Cumulative Produced',
                data: aggregate.produced,
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37, 99, 235, 0.15)',
                fill: false,
                tension: 0.25,
            },
        ];
        if (Array.isArray(aggregate.goal) && aggregate.goal.some((value) => value)) {
            datasets.push({
                label: 'Cumulative Goal',
                data: aggregate.goal,
                borderColor: '#f97316',
                backgroundColor: 'rgba(249, 115, 22, 0.15)',
                fill: false,
                borderDash: [6, 6],
                tension: 0.2,
            });
        }
        const data = {
            labels: aggregate.labels,
            datasets,
        };
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: 'Cumulative Production vs Goal' },
                legend: { position: 'bottom' },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Units' },
                },
            },
        };
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }
        if (cumulativeGoalChart) {
            cumulativeGoalChart.data = data;
            cumulativeGoalChart.options = options;
            cumulativeGoalChart.update();
            return;
        }
        cumulativeGoalChart = new Chart(canvas, { type: 'line', data, options });
        registerExpandableChart(canvas, cumulativeGoalChart);
    };

    const recomputeAdditionalCharts = (rows) => {
        ensureShiftChart(buildShiftAggregate(rows));
        ensureProductTypeChart(buildProductAggregate(rows));
        ensureScrapChart(buildScrapAggregate(rows));
        ensureDowntimeChart(buildDowntimeAggregate(rows));
        ensureCumulativeGoalChart(buildCumulativeGoalAggregate(rows));
    };

    const builderDimensionSelect = document.getElementById('builderDimensionSelect');
    const builderSeriesSelect = document.getElementById('builderSeriesSelect');
    const builderMetricSelect = document.getElementById('builderMetricSelect');
    const builderAggregationSelect = document.getElementById('builderAggregationSelect');
    const builderChartTypeSelect = document.getElementById('builderChartTypeSelect');
    const builderResetButton = document.getElementById('builderResetButton');
    const builderSummary = document.getElementById('customBuilderSummary');

    const updateCustomBuilderChart = () => {
        if (!builderDimensionSelect || !builderMetricSelect) {
            return;
        }
        const dimensionKey = builderDimensionSelect.value || 'date';
        const seriesKey = builderSeriesSelect ? builderSeriesSelect.value : '';
        const metricKey = builderMetricSelect.value || 'gates_produced';
        const aggregation = builderAggregationSelect ? builderAggregationSelect.value : 'sum';
        const chartTypeChoice = builderChartTypeSelect ? builderChartTypeSelect.value : 'bar';

        const grouped = new Map();
        activeBuilderRows.forEach((row) => {
            const metricValueRaw = row?.metrics?.[metricKey];
            if (metricValueRaw === null || typeof metricValueRaw === 'undefined') {
                return;
            }
            const metricValue = Number(metricValueRaw);
            if (!Number.isFinite(metricValue)) {
                return;
            }
            const dimensionValue = getDimensionValue(row, dimensionKey || 'date');
            const seriesValue = seriesKey ? getDimensionValue(row, seriesKey) : '__single__';
            let dimensionGroup = grouped.get(dimensionValue);
            if (!dimensionGroup) {
                dimensionGroup = new Map();
                grouped.set(dimensionValue, dimensionGroup);
            }
            let aggregator = dimensionGroup.get(seriesValue);
            if (!aggregator) {
                aggregator = { sum: 0, count: 0 };
                dimensionGroup.set(seriesValue, aggregator);
            }
            aggregator.sum += metricValue;
            aggregator.count += 1;
        });

        const labels = Array.from(grouped.keys()).sort();
        const includeSeries = Boolean(seriesKey);
        const seriesNames = includeSeries
            ? Array.from(
                  new Set(
                      labels.flatMap((label) =>
                          Array.from(grouped.get(label)?.keys() || [])
                      )
                  )
              )
            : ['__single__'];

        if (!labels.length || !seriesNames.length) {
            toggleChartFallback('customBuilderChart', false);
            if (customBuilderChart) {
                customBuilderChart.destroy();
                customBuilderChart = null;
            }
            if (builderSummary) {
                builderSummary.textContent = 'No data available for the selected configuration.';
            }
            return;
        }

        const dimensionLabelText =
            builderDimensionSelect.options[
                builderDimensionSelect.selectedIndex
            ]?.text || 'Dimension';
        const metricLabelText =
            builderMetricSelect.options[
                builderMetricSelect.selectedIndex
            ]?.text || 'Metric';

        const datasets = [];
        seriesNames.forEach((seriesName, index) => {
            const data = labels.map((label) => {
                const dimensionEntry = grouped.get(label);
                const aggregator = dimensionEntry?.get(seriesName) || { sum: 0, count: 0 };
                const baseValue =
                    aggregation === 'average'
                        ? aggregator.count
                            ? aggregator.sum / aggregator.count
                            : 0
                        : aggregator.sum;
                return Number(baseValue.toFixed(2));
            });
            const paletteColor = chartColorPalette[index % chartColorPalette.length];
            const datasetLabel =
                seriesName === '__single__'
                    ? metricLabelText
                    : seriesName || fallbackDimensionValue;
            datasets.push({
                label: datasetLabel,
                data,
                backgroundColor: paletteColor,
                borderColor: paletteColor,
                fill: chartTypeChoice === 'line' ? false : true,
                tension: chartTypeChoice === 'line' ? 0.2 : undefined,
            });
        });

        const hasAnyData = datasets.some((dataset) =>
            dataset.data.some((value) => Number.isFinite(value) && value !== 0)
        );
        toggleChartFallback('customBuilderChart', hasAnyData);
        if (!hasAnyData) {
            if (customBuilderChart) {
                customBuilderChart.destroy();
                customBuilderChart = null;
            }
            if (builderSummary) {
                builderSummary.textContent = 'No data available for the selected configuration.';
            }
            return;
        }

        const chartType = chartTypeChoice === 'line' ? 'line' : 'bar';
        const isStacked = chartTypeChoice === 'stacked';

        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' },
                title: {
                    display: true,
                    text: `${metricLabelText} by ${dimensionLabelText}`,
                },
            },
            scales: {
                x: { stacked: isStacked },
                y: {
                    beginAtZero: true,
                    stacked: isStacked,
                    title: {
                        display: true,
                        text:
                            aggregation === 'average'
                                ? `${metricLabelText} (avg)`
                                : metricLabelText,
                    },
                },
            },
        };

        const canvas = document.getElementById('customBuilderChart');
        if (!canvas) {
            return;
        }
        if (customBuilderChart) {
            customBuilderChart.destroy();
        }
        customBuilderChart = new Chart(canvas, {
            type: chartType,
            data: { labels, datasets },
            options,
        });
        registerExpandableChart(canvas, customBuilderChart);

        if (builderSummary) {
            const dimensionCount = labels.length;
            builderSummary.textContent = `${
                aggregation === 'average' ? 'Average' : 'Total'
            } ${metricLabelText} across ${dimensionCount} ${dimensionLabelText}${
                dimensionCount === 1 ? '' : 's'
            }.`;
        }
    };

    const applyBuilderDefaults = () => {
        const defaults = customBuilderDefaults || {};
        if (builderDimensionSelect) {
            builderDimensionSelect.value = defaults.dimension || '';
        }
        if (builderSeriesSelect) {
            builderSeriesSelect.value = defaults.series || '';
        }
        if (builderMetricSelect) {
            builderMetricSelect.value = defaults.metric || 'gates_produced';
        }
        if (builderAggregationSelect) {
            builderAggregationSelect.value = defaults.aggregation || 'sum';
        }
        if (builderChartTypeSelect) {
            builderChartTypeSelect.value = defaults.chart_type || 'bar';
        }
    };

    const registerBuilderEvents = () => {
        const controls = [
            builderDimensionSelect,
            builderSeriesSelect,
            builderMetricSelect,
            builderAggregationSelect,
            builderChartTypeSelect,
        ];
        controls.forEach((control) => {
            if (control) {
                control.addEventListener('change', () => updateCustomBuilderChart());
            }
        });
        if (builderResetButton) {
            builderResetButton.addEventListener('click', () => {
                applyBuilderDefaults();
                updateCustomBuilderChart();
            });
        }
    };

    const dailyDetailToggle = document.getElementById('dailyDetailToggle');
    const dailyDetailContainer = document.getElementById('dailyDetailContainer');

    if (dailyDetailToggle && dailyDetailContainer) {
        const showText = dailyDetailToggle.getAttribute('data-show-text') || 'Show Daily Detail';
        const hideText = dailyDetailToggle.getAttribute('data-hide-text') || 'Hide Daily Detail';

        const updateToggleState = (expanded) => {
            dailyDetailToggle.setAttribute('aria-expanded', String(expanded));
            dailyDetailToggle.textContent = expanded ? hideText : showText;
            dailyDetailContainer.hidden = !expanded;
        };

        dailyDetailToggle.addEventListener('click', () => {
            const expanded = dailyDetailToggle.getAttribute('aria-expanded') === 'true';
            updateToggleState(!expanded);
        });
    }

    const initializeSortableTable = (tableElement) => {
        const headerCells = Array.from(tableElement.querySelectorAll('thead th'));
        const tableBody = tableElement.querySelector('tbody');
        if (!tableBody || !headerCells.length) {
            return;
        }

        const allRows = Array.from(tableBody.querySelectorAll('tr'));
        allRows.forEach((row, index) => {
            row.dataset.originalOrder = String(index);
        });

        const getSortValue = (row, columnIndex) => {
            const cell = row.children[columnIndex];
            if (!cell) {
                return '';
            }
            const value = cell.getAttribute('data-sort-value');
            return value !== null ? value : cell.textContent.trim();
        };

        const compareValues = (valueA, valueB) => {
            const numericA = Number(valueA);
            const numericB = Number(valueB);
            const aIsNumber = Number.isFinite(numericA);
            const bIsNumber = Number.isFinite(numericB);

            if (aIsNumber && bIsNumber) {
                return numericA - numericB;
            }

            const stringA = String(valueA).toLowerCase();
            const stringB = String(valueB).toLowerCase();
            if (stringA < stringB) {
                return -1;
            }
            if (stringA > stringB) {
                return 1;
            }
            return 0;
        };

        const sortByColumn = (columnIndex) => {
            const activeHeader = headerCells[columnIndex];
            if (!activeHeader) {
                return;
            }

            const currentDirection = activeHeader.getAttribute('data-sort-direction') || 'none';
            let nextDirection = 'asc';
            if (currentDirection === 'asc') {
                nextDirection = 'desc';
            } else if (currentDirection === 'desc') {
                nextDirection = 'none';
            }

            headerCells.forEach((header, headerIndex) => {
                if (headerIndex === columnIndex) {
                    header.setAttribute('data-sort-direction', nextDirection);
                    header.setAttribute('aria-sort', nextDirection === 'none' ? 'none' : nextDirection);
                } else {
                    header.removeAttribute('data-sort-direction');
                    header.setAttribute('aria-sort', 'none');
                }
            });

            let sortedRows = Array.from(allRows);
            if (nextDirection === 'none') {
                sortedRows.sort((rowA, rowB) => {
                    const indexA = Number.parseInt(rowA.dataset.originalOrder || '0', 10);
                    const indexB = Number.parseInt(rowB.dataset.originalOrder || '0', 10);
                    return indexA - indexB;
                });
            } else {
                sortedRows.sort((rowA, rowB) => {
                    const valueA = getSortValue(rowA, columnIndex);
                    const valueB = getSortValue(rowB, columnIndex);
                    const comparison = compareValues(valueA, valueB);
                    return nextDirection === 'asc' ? comparison : -comparison;
                });
            }

            sortedRows.forEach((row) => {
                tableBody.appendChild(row);
            });
        };

        headerCells.forEach((header, index) => {
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-sort', 'none');
            header.addEventListener('click', () => sortByColumn(index));
            header.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    sortByColumn(index);
                }
            });
        });
    };

    const historyTable = document.querySelector('.production-history-table');
    if (historyTable) {
        initializeSortableTable(historyTable);
    }

    const weekendBackgroundPlugin = {
        id: 'weekendBackground',
        beforeDraw(chart, _args, pluginOptions) {
            if (!pluginOptions || !pluginOptions.enabled) {
                return;
            }

            const xScale = chart.scales?.x;
            const chartArea = chart.chartArea;
            if (!xScale || !chartArea) {
                return;
            }

            const labels = chart.data?.labels || [];
            if (!labels.length) {
                return;
            }

            const weekendRanges = [];
            let currentRange = null;

            labels.forEach((label, index) => {
                if (isWeekendLabel(label)) {
                    if (!currentRange) {
                        currentRange = { start: index, end: index };
                    } else {
                        currentRange.end = index;
                    }
                } else if (currentRange) {
                    weekendRanges.push(currentRange);
                    currentRange = null;
                }
            });

            if (currentRange) {
                weekendRanges.push(currentRange);
            }

            if (!weekendRanges.length) {
                return;
            }

            const { ctx } = chart;
            const { left, right, top, bottom } = chartArea;

            const getCenterForIndex = (index) => {
                if (typeof xScale.getPixelForValue === 'function') {
                    try {
                        return xScale.getPixelForValue(labels[index], index);
                    } catch (error) {
                        // Fallback to tick-based calculation below
                    }
                }
                if (typeof xScale.getPixelForTick === 'function') {
                    return xScale.getPixelForTick(index);
                }
                return Number.NaN;
            };

            const getBoundary = (index, direction) => {
                if (labels.length === 1) {
                    return direction === 'left' ? left : right;
                }

                const center = getCenterForIndex(index);
                if (!Number.isFinite(center)) {
                    return direction === 'left' ? left : right;
                }

                if (direction === 'left') {
                    if (index === 0) {
                        const nextCenter = getCenterForIndex(1);
                        if (Number.isFinite(nextCenter)) {
                            return center - (nextCenter - center) / 2;
                        }
                        return left;
                    }
                    const previousCenter = getCenterForIndex(index - 1);
                    if (!Number.isFinite(previousCenter)) {
                        return left;
                    }
                    return center - (center - previousCenter) / 2;
                }

                if (index === labels.length - 1) {
                    const previousCenter = getCenterForIndex(index - 1);
                    if (Number.isFinite(previousCenter)) {
                        return center + (center - previousCenter) / 2;
                    }
                    return right;
                }

                const nextCenter = getCenterForIndex(index + 1);
                if (!Number.isFinite(nextCenter)) {
                    return right;
                }
                return center + (nextCenter - center) / 2;
            };

            ctx.save();
            ctx.fillStyle = pluginOptions.color || 'rgba(0, 0, 0, 0.08)';
            ctx.beginPath();
            ctx.rect(left, top, right - left, bottom - top);
            ctx.clip();

            weekendRanges.forEach((range) => {
                const rangeLeft = Math.max(left, getBoundary(range.start, 'left'));
                const rangeRight = Math.min(right, getBoundary(range.end, 'right'));

                if (!Number.isFinite(rangeLeft) || !Number.isFinite(rangeRight) || rangeRight <= rangeLeft) {
                    return;
                }

                ctx.fillRect(rangeLeft, top, rangeRight - rangeLeft, bottom - top);
            });

            ctx.restore();
        },
    };

    const stackedTotalsPlugin = {
        id: 'stackedTotals',
        defaults: {
            enabled: true,
            color: '#111827',
            font: {
                weight: '600',
            },
            yOffset: -6,
            formatter: (value) => value.toLocaleString(),
        },
        afterDatasetsDraw(chart, _args, pluginOptions) {
            const options = pluginOptions || {};
            const enabled = options.enabled ?? stackedTotalsPlugin.defaults.enabled;
            if (!enabled) {
                return;
            }

            const labels = chart.data?.labels || [];
            if (!labels.length) {
                return;
            }

            const datasets = chart.data?.datasets || [];
            const stackedMetas = datasets.reduce((accumulator, dataset, index) => {
                if (!dataset || dataset.type === 'line') {
                    return accumulator;
                }

                const meta = chart.getDatasetMeta(index);
                if (!meta || meta.type !== 'bar') {
                    return accumulator;
                }

                if (dataset.stack !== 'gates-produced') {
                    return accumulator;
                }

                if (typeof chart.isDatasetVisible === 'function' && !chart.isDatasetVisible(index)) {
                    return accumulator;
                }

                accumulator.push({ dataset, meta });
                return accumulator;
            }, []);

            if (!stackedMetas.length) {
                return;
            }

            const ctx = chart.ctx;
            const globalFont = (Chart.defaults && Chart.defaults.font) || {};
            const fontOptions = Object.assign({}, globalFont, options.font || {});
            const fontSize = fontOptions.size || 12;
            const fontFamily = fontOptions.family || globalFont.family || 'sans-serif';
            const fontStyle = fontOptions.style || globalFont.style || 'normal';
            const fontWeight = fontOptions.weight || 'bold';
            const yOffset = typeof options.yOffset === 'number'
                ? options.yOffset
                : stackedTotalsPlugin.defaults.yOffset;

            const formatter = typeof options.formatter === 'function'
                ? options.formatter
                : stackedTotalsPlugin.defaults.formatter;

            const color = options.color || stackedTotalsPlugin.defaults.color;

            ctx.save();
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            const fontParts = [];
            if (fontStyle) {
                fontParts.push(fontStyle);
            }
            if (fontWeight) {
                fontParts.push(fontWeight);
            }
            fontParts.push(`${fontSize}px`);
            fontParts.push(fontFamily);
            ctx.font = fontParts.join(' ');

            labels.forEach((_, dataIndex) => {
                let total = 0;
                let hasValue = false;
                let topY = Number.POSITIVE_INFINITY;

                stackedMetas.forEach(({ dataset, meta }) => {
                    const value = Array.isArray(dataset.data)
                        ? dataset.data[dataIndex]
                        : undefined;
                    if (typeof value === 'number' && Number.isFinite(value)) {
                        total += value;
                        hasValue = true;
                    }

                    const element = meta.data && meta.data[dataIndex];
                    if (element && Number.isFinite(element.y)) {
                        topY = Math.min(topY, element.y);
                    }
                });

                if (!hasValue || !Number.isFinite(topY)) {
                    return;
                }

                const formatted = formatter(total);
                if (formatted === null || formatted === undefined) {
                    return;
                }

                const xPosition = stackedMetas[0].meta.data?.[dataIndex]?.x;
                if (!Number.isFinite(xPosition)) {
                    return;
                }

                ctx.fillText(String(formatted), xPosition, topY + yOffset);
            });

            ctx.restore();
        },
    };

    if (typeof Chart !== 'undefined') {
        Chart.register(weekendBackgroundPlugin);
        Chart.register(stackedTotalsPlugin);
    }

    if (chartLabels.length) {
        const stackedDatasetList = Array.isArray(stackedDatasets) ? stackedDatasets : [];
        const overlayDatasetList = Array.isArray(overlayDatasets) ? overlayDatasets : [];
        const lineDatasetList = Array.isArray(lineDatasets) ? lineDatasets : [];

        const deepCloneDataset = (dataset) => JSON.parse(JSON.stringify(dataset));
        const deepCloneDatasets = (datasets) => datasets.map((dataset) => deepCloneDataset(dataset));

        const originalLabels = chartLabels.slice();
        const originalStackedDatasets = deepCloneDatasets(stackedDatasetList);
        const originalOverlayDatasets = deepCloneDatasets(overlayDatasetList);
        const originalLineDatasets = deepCloneDatasets(lineDatasetList);
        const weekendMask = originalLabels.map((label) => isWeekendLabel(label));

        const cloneAndFilterDataset = (dataset, includeWeekends) => {
            const clonedDataset = deepCloneDataset(dataset);

            if (!includeWeekends && Array.isArray(dataset.data) && dataset.data.length === weekendMask.length) {
                clonedDataset.data = dataset.data.filter((_, index) => !weekendMask[index]);
            }

            if (!includeWeekends) {
                Object.keys(dataset).forEach((key) => {
                    if (key === 'data') {
                        return;
                    }
                    const value = dataset[key];
                    if (Array.isArray(value) && value.length === weekendMask.length) {
                        clonedDataset[key] = value.filter((_, index) => !weekendMask[index]);
                    }
                });
            }

            return clonedDataset;
        };

        const buildChartData = (includeWeekends) => {
            const labels = includeWeekends
                ? originalLabels.slice()
                : originalLabels.filter((_, index) => !weekendMask[index]);

            const stacked = originalStackedDatasets.map((dataset) => cloneAndFilterDataset(dataset, includeWeekends));
            const overlays = originalOverlayDatasets.map((dataset) => cloneAndFilterDataset(dataset, includeWeekends));
            const line = originalLineDatasets.map((dataset) => cloneAndFilterDataset(dataset, includeWeekends));

            return {
                labels,
                combinedDatasets: stacked.concat(overlays),
                lineDatasets: line,
            };
        };

        let currentIncludeWeekends = true;
        const collapseToggle = document.getElementById('collapseWeekendsToggle');
        if (collapseToggle) {
            collapseToggle.checked = !currentIncludeWeekends;
        }

        const initialState = buildChartData(currentIncludeWeekends);
        activeBuilderRows = filterRowsForWeekends(currentIncludeWeekends);

        const barContext = document.getElementById('gatesProducedChart');
        let barChart = null;
        if (barContext) {
            const primaryScale = {
                stacked: true,
                beginAtZero: chartAxisSettings.primary.min === null,
                title: {
                    display: true,
                    text: 'Units',
                },
            };

            if (chartAxisSettings.primary.min !== null) {
                primaryScale.min = chartAxisSettings.primary.min;
            }
            if (chartAxisSettings.primary.max !== null) {
                primaryScale.max = chartAxisSettings.primary.max;
            }
            if (chartAxisSettings.primary.step !== null) {
                primaryScale.ticks = Object.assign({}, primaryScale.ticks, {
                    stepSize: chartAxisSettings.primary.step,
                });
            }

            const secondaryScale = {
                position: 'right',
                beginAtZero: chartAxisSettings.secondary.min === null,
                grid: {
                    drawOnChartArea: false,
                },
                title: {
                    display: true,
                    text: 'Output per Labor Hour',
                },
            };
            if (chartAxisSettings.secondary.min !== null) {
                secondaryScale.min = chartAxisSettings.secondary.min;
            }
            if (chartAxisSettings.secondary.max !== null) {
                secondaryScale.max = chartAxisSettings.secondary.max;
            }
            if (chartAxisSettings.secondary.step !== null) {
                secondaryScale.ticks = Object.assign({}, secondaryScale.ticks, {
                    stepSize: chartAxisSettings.secondary.step,
                });
            }

            barChart = new Chart(barContext, {

                type: 'bar',
                data: {
                    labels: initialState.labels,
                    datasets: initialState.combinedDatasets,
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        weekendBackground: {
                            enabled: currentIncludeWeekends,
                            color: 'rgba(0, 0, 0, 0.08)',
                        },
                        stackedTotals: {
                            enabled: true,
                            color: '#0f172a',
                            font: {
                                weight: '600',
                            },
                            yOffset: -8,
                        },
                        title: {
                            display: true,
                            text: 'Gates Produced by Customer',
                        },
                        legend: {
                            position: 'bottom',
                        },
                    },
                    scales: {
                        x: {
                            stacked: true,
                        },
                        y: primaryScale,
                        'y-output': secondaryScale,
                    },
                },
            });
        }

        const lineContext = document.getElementById('cumulativeChart');
        let lineChart = null;
        if (lineContext) {
            lineChart = new Chart(lineContext, {

                type: 'line',
                data: {
                    labels: initialState.labels,
                    datasets: initialState.lineDatasets,
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        weekendBackground: {
                            enabled: currentIncludeWeekends,
                            color: 'rgba(0, 0, 0, 0.08)',
                        },
                        title: {
                            display: true,
                            text: 'Cumulative Month-to-Date Totals',
                        },
                        legend: {
                            position: 'bottom',
                        },
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Units',
                            },
                        },
                    },
                },
            });
        }

        const updateChartsForWeekendState = (includeWeekends) => {
            if (includeWeekends === currentIncludeWeekends) {
                return;
            }
            currentIncludeWeekends = includeWeekends;

            const updatedState = buildChartData(includeWeekends);

            if (barChart) {
                barChart.data.labels = updatedState.labels;
                barChart.data.datasets = updatedState.combinedDatasets;
                if (barChart.options?.plugins?.weekendBackground) {
                    barChart.options.plugins.weekendBackground.enabled = includeWeekends;
                }
                barChart.update();
            }

            if (lineChart) {
                lineChart.data.labels = updatedState.labels;
                lineChart.data.datasets = updatedState.lineDatasets;
                if (lineChart.options?.plugins?.weekendBackground) {
                    lineChart.options.plugins.weekendBackground.enabled = includeWeekends;
                }
                lineChart.update();
            }

            if (collapseToggle) {
                collapseToggle.checked = !includeWeekends;
            }

            activeBuilderRows = filterRowsForWeekends(includeWeekends);
            recomputeAdditionalCharts(activeBuilderRows);
            updateCustomBuilderChart();
        };

        if (collapseToggle) {
            collapseToggle.addEventListener('change', (event) => {
                const includeWeekends = !event.target.checked;
                updateChartsForWeekendState(includeWeekends);
            });
        }

        const chartModal = document.getElementById('chartModal');
        const modalCanvas = document.getElementById('expandedChart');
        const dismissButtons = chartModal ? chartModal.querySelectorAll('[data-modal-dismiss]') : [];
        let modalChart = null;

        const cloneChartConfig = (chartInstance) => {
            const clonedData = JSON.parse(JSON.stringify(chartInstance.data));
            const clonedOptions = JSON.parse(JSON.stringify(chartInstance.options || {}));
            return {
                type: chartInstance.config.type,
                data: clonedData,
                options: Object.assign({}, clonedOptions, {
                    responsive: true,
                    maintainAspectRatio: false,
                }),
            };
        };

        const closeChartModal = () => {
            if (!chartModal) {
                return;
            }
            if (modalChart) {
                modalChart.destroy();
                modalChart = null;
            }
            chartModal.classList.add('is-hidden');
            chartModal.setAttribute('aria-label', 'Expanded chart view');
        };

        const openChartModal = (chartInstance) => {
            if (!chartModal || !modalCanvas || !chartInstance) {
                return;
            }

            chartModal.classList.remove('is-hidden');

            window.requestAnimationFrame(() => {
                const config = cloneChartConfig(chartInstance);
                if (modalChart) {
                    modalChart.destroy();
                    modalChart = null;
                }
                modalChart = new Chart(modalCanvas.getContext('2d'), config);
                const modalTitle = chartInstance.options?.plugins?.title?.text;
                if (modalTitle) {
                    chartModal.setAttribute('aria-label', `Expanded chart view: ${modalTitle}`);
                } else {
                    chartModal.setAttribute('aria-label', 'Expanded chart view');
                }
            });
        };

        if (chartModal) {
            chartModal.addEventListener('click', (event) => {
                if (event.target === chartModal) {
                    closeChartModal();
                }
            });
        }

        dismissButtons.forEach((button) => {
            button.addEventListener('click', closeChartModal);
        });

        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') {
                return;
            }
            if (chartModal && !chartModal.classList.contains('is-hidden')) {
                closeChartModal();
            }
            if (emailModal && !emailModal.classList.contains('is-hidden')) {
                closeEmailModal();
            }
        });

        const registerChartForExpansion = (canvasElement, chartInstance) => {
            if (!canvasElement || !chartInstance) {
                return;
            }

            canvasElement.classList.add('chart-expandable');
            canvasElement.setAttribute('tabindex', '0');
            canvasElement.setAttribute('role', 'button');

            const originalLabel = canvasElement.getAttribute('aria-label') || 'Chart';
            if (!originalLabel.toLowerCase().includes('click to expand')) {
                canvasElement.setAttribute('aria-label', `${originalLabel} (click to expand)`);
            }

            canvasElement.addEventListener('click', () => {
                openChartModal(chartInstance);
            });

            canvasElement.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    openChartModal(chartInstance);
                }
            });
        };

        if (typeof window !== 'undefined') {
            window.__registerChartExpansion = registerChartForExpansion;
        }

        recomputeAdditionalCharts(activeBuilderRows);

        registerChartForExpansion(barContext, barChart);
        registerChartForExpansion(lineContext, lineChart);

        const emailButton = document.getElementById('emailDataButton');
        const emailModal = document.getElementById('emailDataModal');
        const emailModalDialog = emailModal ? emailModal.querySelector('.email-modal-dialog') : null;
        const emailCloseButtons = emailModal ? emailModal.querySelectorAll('[data-email-dismiss]') : [];
        const emailBarImage = document.getElementById('emailDataBarImage');
        const emailLineImage = document.getElementById('emailDataLineImage');
        const emailNoteContainer = document.getElementById('emailDataNote');
        const emailSubtitle = document.getElementById('emailDataSubtitle');
        const copyEmailNoteButton = document.getElementById('copyEmailNoteButton');
        let latestBarChartImageDataUrl = null;

        const renderEmailNote = () => {
            if (!emailNoteContainer) {
                return;
            }

            emailNoteContainer.innerHTML = '';

            if (!emailPreview) {
                const emptyMessage = document.createElement('p');
                emptyMessage.classList.add('email-modal-note-empty');
                emptyMessage.textContent = 'No notes are available for the selected date range.';
                emailNoteContainer.appendChild(emptyMessage);
                if (emailSubtitle) {
                    emailSubtitle.textContent = '';
                }
                return;
            }

            const noteText = (emailPreview.notes || '').trim();
            const noteDateParts = [emailPreview.day_of_week, emailPreview.date_display]
                .filter(Boolean)
                .join(', ');
            if (emailSubtitle) {
                emailSubtitle.textContent = noteDateParts || '';
            }

            if (!noteText) {
                const placeholder = document.createElement('p');
                placeholder.classList.add('email-modal-note-empty');
                placeholder.textContent = 'No notes were recorded for this day.';
                emailNoteContainer.appendChild(placeholder);
                return;
            }

            noteText.split('\n').forEach((line) => {
                const paragraph = document.createElement('p');
                paragraph.textContent = line;
                emailNoteContainer.appendChild(paragraph);
            });
        };

        const closeEmailModal = () => {
            if (!emailModal) {
                return;
            }
            emailModal.classList.add('is-hidden');
            emailModal.removeAttribute('aria-label');
        };

        const openEmailModal = () => {
            if (!emailModal || !emailButton || emailButton.disabled) {
                return;
            }

            latestBarChartImageDataUrl = null;

            if (emailBarImage && barChart) {
                try {
                    const chartImage = barChart.toBase64Image('image/png', 1);
                    emailBarImage.src = chartImage;
                    latestBarChartImageDataUrl = chartImage;
                } catch (error) {
                    emailBarImage.removeAttribute('src');
                }
            }
            if (emailLineImage && lineChart) {
                try {
                    emailLineImage.src = lineChart.toBase64Image();
                } catch (error) {
                    emailLineImage.removeAttribute('src');
                }
            }

            renderEmailNote();

            if (emailPreview) {
                const labelParts = [
                    'Email data preview',
                    emailPreview.day_of_week,
                    emailPreview.date_display,
                ].filter(Boolean);
                emailModal.setAttribute('aria-label', labelParts.join(': '));
            }

            emailModal.classList.remove('is-hidden');
            window.requestAnimationFrame(() => {
                if (emailModalDialog) {
                    emailModalDialog.focus();
                }
            });
        };

        if (emailButton && emailModal) {
            emailButton.addEventListener('click', openEmailModal);
        }

        if (emailModal) {
            emailModal.addEventListener('click', (event) => {
                if (event.target === emailModal) {
                    closeEmailModal();
                }
            });
        }

        emailCloseButtons.forEach((button) => {
            button.addEventListener('click', closeEmailModal);
        });

        const selectEmailNoteText = () => {
            if (!emailNoteContainer || !window.getSelection || !document.createRange) {
                return;
            }

            const selection = window.getSelection();
            if (!selection) {
                return;
            }

            selection.removeAllRanges();
            const range = document.createRange();
            range.selectNodeContents(emailNoteContainer);
            selection.addRange(range);
        };

        const dataUrlToBlob = async (dataUrl) => {
            if (!dataUrl || typeof dataUrl !== 'string') {
                return null;
            }

            try {
                const response = await fetch(dataUrl);
                return await response.blob();
            } catch (error) {
                return null;
            }
        };

        const fallbackCopyToClipboard = (text) => {
            if (!document.body || typeof document.execCommand !== 'function') {
                return false;
            }

            const hiddenField = document.createElement('textarea');
            hiddenField.value = text;
            hiddenField.setAttribute('readonly', '');
            hiddenField.setAttribute('aria-hidden', 'true');
            hiddenField.style.position = 'fixed';
            hiddenField.style.top = '-1000px';
            hiddenField.style.left = '-1000px';
            hiddenField.style.opacity = '0';
            hiddenField.style.pointerEvents = 'none';

            document.body.appendChild(hiddenField);

            try {
                hiddenField.focus({ preventScroll: true });
            } catch (error) {
                hiddenField.focus();
            }
            hiddenField.select();

            let succeeded = false;
            try {
                succeeded = document.execCommand('copy');
            } catch (error) {
                succeeded = false;
            }

            hiddenField.remove();

            if (window.getSelection) {
                const selection = window.getSelection();
                if (selection && selection.removeAllRanges) {
                    selection.removeAllRanges();
                }
            }

            return succeeded;
        };

        const copyNoteToClipboard = async (text) => {
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (error) {
                    // Continue to the fallback below when direct clipboard access fails.
                }
            }

            return fallbackCopyToClipboard(text);
        };

        const copyChartAndNotesToClipboard = async (text) => {
            if (!latestBarChartImageDataUrl) {
                return false;
            }

            if (!navigator.clipboard || typeof navigator.clipboard.write !== 'function' || typeof ClipboardItem === 'undefined') {
                return false;
            }

            const imageBlob = await dataUrlToBlob(latestBarChartImageDataUrl);
            if (!imageBlob) {
                return false;
            }

            const clipboardContents = {
                'text/plain': new Blob([text], { type: 'text/plain' }),
            };
            clipboardContents[imageBlob.type || 'image/png'] = imageBlob;

            try {
                await navigator.clipboard.write([new ClipboardItem(clipboardContents)]);
                return true;
            } catch (error) {
                return false;
            }
        };

        const withTemporaryLabel = (button, label) => {
            if (!button) {
                return;
            }

            if (!button.dataset.originalLabel) {
                button.dataset.originalLabel = button.textContent;
            }

            button.textContent = label;
            window.setTimeout(() => {
                button.textContent = button.dataset.originalLabel;
            }, 2000);
        };

        if (copyEmailNoteButton) {
            copyEmailNoteButton.addEventListener('click', async () => {
                const noteText = emailPreview && emailPreview.notes
                    ? emailPreview.notes.trim()
                    : 'No notes were recorded for this day.';

                const copiedChartAndNotes = await copyChartAndNotesToClipboard(noteText);
                if (copiedChartAndNotes) {
                    withTemporaryLabel(copyEmailNoteButton, 'Notes & chart copied!');
                    return;
                }

                const copiedNotes = await copyNoteToClipboard(noteText);

                if (copiedNotes) {
                    const fallbackLabel = latestBarChartImageDataUrl
                        ? 'Notes copied (chart unavailable)'
                        : 'Notes copied!';
                    withTemporaryLabel(copyEmailNoteButton, fallbackLabel);
                    return;
                }

                selectEmailNoteText();
                withTemporaryLabel(copyEmailNoteButton, 'Copy failed');
            });
        }
    }

    if (!chartLabels.length) {
        recomputeAdditionalCharts(activeBuilderRows);
    }
    applyBuilderDefaults();
    registerBuilderEvents();
    updateCustomBuilderChart();
</script>
{% endblock %}
