{% extends "base.html" %}

{% block content %}
<nav class="production-nav" aria-label="Production pages">
    <a href="{{ url_for('production.daily_entry') }}" class="production-nav-link">Daily Entry</a>
    <a href="{{ url_for('production.history') }}" class="production-nav-link is-active">History</a>
    <a href="{{ url_for('production.production_settings') }}" class="production-nav-link">Settings</a>
</nav>

<h2>Production History</h2>
<p class="section-help">Select a date range to review production totals, customer breakdowns, and month-to-date trends.</p>
{% if grouped_customer_names %}
    <p class="chart-note">Customers grouped into the <strong>Other</strong> series: {{ grouped_customer_names | join(', ') }}.</p>
{% endif %}


<form method="get" class="date-range-form">
    <div class="form-field">
        <label for="start_date" class="field-label">Start Date</label>
        <input type="date" id="start_date" name="start_date" value="{{ start_date.isoformat() }}">
    </div>
    <div class="form-field">
        <label for="end_date" class="field-label">End Date</label>
        <input type="date" id="end_date" name="end_date" value="{{ end_date.isoformat() }}">
    </div>
    <div class="form-actions">
        <button type="submit">Update Range</button>
    </div>
</form>

{% if not chart_labels %}
    <p class="chart-empty">No production records were found for the selected dates.</p>
{% else %}
    <section class="dashboard-section">
        <h3>Visual Breakdown</h3>
        <div class="chart-controls">
            <label class="chart-toggle" for="collapseWeekendsToggle">
                <input type="checkbox" id="collapseWeekendsToggle" name="collapse_weekends">
                Collapse weekends
            </label>
            <button type="button" id="emailDataButton" class="email-data-btn" aria-haspopup="dialog">
                Email Data View
            </button>
        </div>
        <div class="chart-grid">
            <div class="chart-card">
                <canvas id="gatesProducedChart" aria-label="Stacked column chart showing gates produced per customer"></canvas>
            </div>
            <div class="chart-card">
                <canvas id="cumulativeChart" aria-label="Line chart showing cumulative month-to-date production totals"></canvas>
            </div>
        </div>
    </section>

    <div class="chart-modal is-hidden" id="chartModal" role="dialog" aria-modal="true" aria-label="Expanded chart view">
        <div class="chart-modal-dialog">
            <button type="button" class="chart-modal-close" data-modal-dismiss aria-label="Close expanded chart">&times;</button>
            <canvas id="expandedChart" aria-label="Expanded chart canvas"></canvas>
        </div>
    </div>

    <div class="chart-modal is-hidden" id="emailDataModal" role="dialog" aria-modal="true" aria-hidden="true" aria-label="Email-friendly production snapshot">
        <div class="chart-modal-dialog email-modal-dialog">
            <button type="button" class="chart-modal-close" data-modal-dismiss aria-label="Close email-friendly view">&times;</button>
            <header class="email-modal-header">
                <div class="email-modal-heading">
                    <h3>Email-Friendly Production Snapshot</h3>
                    <p class="email-modal-description">Copy the notes and charts below into an email or chat update.</p>
                </div>
                <label for="emailDataDateSelect" class="email-modal-date">
                    <span>Select notes date</span>
                    <select id="emailDataDateSelect" name="email_data_date">
                        {% for label in chart_labels %}
                            <option value="{{ label }}">{{ label }}</option>
                        {% endfor %}
                    </select>
                </label>
            </header>
            <section class="email-notes" aria-live="polite">
                <h4>Daily Notes</h4>
                <p id="emailDataNotes" class="email-notes-copy">No notes recorded for this date.</p>
            </section>
            <div class="email-chart-grid">
                <figure class="email-chart-card">
                    <figcaption>Gates Produced by Customer</figcaption>
                    <div class="email-chart-canvas">
                        <canvas id="emailBarChart" role="img" aria-label="Email chart showing gates produced by customer"></canvas>
                    </div>
                </figure>
                <figure class="email-chart-card">
                    <figcaption>Cumulative Month-to-Date Totals</figcaption>
                    <div class="email-chart-canvas">
                        <canvas id="emailLineChart" role="img" aria-label="Email chart showing cumulative month-to-date totals"></canvas>
                    </div>
                </figure>
            </div>
        </div>
    </div>

    <section class="dashboard-section">
        <h3>Daily Detail</h3>
        <p class="section-help">Labor hours assume an 8-hour base shift per employee plus the overtime entered for each section.</p>
        <div class="table-scroll">
            <table class="inventory-table production-history-table">
                <thead>
                    <tr>
                        <th scope="col">Date</th>
                        <th scope="col">Day</th>
                        <th scope="col">Gates Produced</th>
                        <th scope="col">Gates Packaged</th>
                        <th scope="col">Gates Labor<br><small>Employees / OT / Hours</small></th>
                        <th scope="col">Output per Labor Hour<br><small>Gates Combined</small></th>
                        <th scope="col">Controllers<br><small>4 Stop / 6 Stop</small></th>
                        <th scope="col">Door Locks<br><small>LH / RH</small></th>
                        <th scope="col">Operators</th>
                        <th scope="col">COPs</th>
                        <th scope="col">Additional Labor<br><small>Employees / OT / Hours</small></th>
                        <th scope="col">Additional Output<br><small>Units per Labor Hour</small></th>
                        <th scope="col">Notes</th>
                    </tr>
                </thead>
                <tbody>
                    {% for row in table_rows %}
                        <tr>
                            <td>{{ row.record.entry_date.strftime('%Y-%m-%d') }}</td>
                            <td>{{ row.record.day_of_week }}</td>
                            <td>
                                <strong>{{ row.produced_sum }}</strong>
                                <div class="totals-breakdown">
                                    {% for customer in customers %}
                                        <span>{{ customer.name }}: {{ row.per_customer_produced.get(customer.id, 0) }}</span>

                                    {% endfor %}
                                </div>
                            </td>
                            <td>
                                <strong>{{ row.packaged_sum }}</strong>
                                <div class="totals-breakdown">
                                    {% for customer in customers %}
                                        <span>{{ customer.name }}: {{ row.per_customer_packaged.get(customer.id, 0) }}</span>

                                    {% endfor %}
                                </div>
                            </td>
                            <td>
                                <div class="totals-breakdown">
                                    <span>Employees: {{ row.gates_employees }}</span>
                                    <span>OT Hours: {{ row.gates_hours_ot }}</span>
                                    <span>Total Hours: {{ row.gates_total_hours }}</span>
                                </div>
                            </td>
                            <td>
                                {% if row.gates_output_per_hour %}
                                    <strong>{{ row.gates_output_per_hour }}</strong>
                                {% endif %}
                                {% if row.output_variables %}
                                    <div class="totals-breakdown">
                                        {% for metric in row.output_variables %}
                                            <span>{{ metric.label }}: {{ metric.value }}</span>
                                        {% endfor %}
                                    </div>
                                {% elif not row.gates_output_per_hour %}
                                    —
                                {% endif %}
                            </td>
                            <td>
                                <div class="metric-pair">
                                    <span>{{ row.record.controllers_4_stop }}</span>
                                    <span>{{ row.record.controllers_6_stop }}</span>
                                </div>
                            </td>
                            <td>
                                <div class="metric-pair">
                                    <span>{{ row.record.door_locks_lh }}</span>
                                    <span>{{ row.record.door_locks_rh }}</span>
                                </div>
                            </td>
                            <td>{{ row.operators_total }}</td>
                            <td>{{ row.cops_total }}</td>
                            <td>
                                <div class="totals-breakdown">
                                    <span>Employees: {{ row.additional_employees }}</span>
                                    <span>OT Hours: {{ row.additional_hours_ot }}</span>
                                    <span>Total Hours: {{ row.additional_total_hours }}</span>
                                </div>
                            </td>
                            <td>
                                {% if row.additional_per_hour %}
                                    <div class="totals-breakdown">
                                        {% for metric in row.additional_per_hour %}
                                            <span>{{ metric.label }}: {{ metric.per_hour }}</span>
                                        {% endfor %}
                                    </div>
                                {% else %}
                                    —
                                {% endif %}
                            </td>
                            <td>{{ row.record.daily_notes or '—' }}</td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </section>
{% endif %}
{% endblock %}

{% block extra_scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const chartLabels = {{ chart_labels|tojson }};
    const stackedDatasets = {{ stacked_datasets|tojson }};
    const overlayDatasets = {{ overlay_datasets|tojson }};
    const lineDatasets = {{ line_datasets|tojson }};
    const chartAxisSettings = {{ chart_axis_settings|tojson }};
    const notesByDate = {{ notes_by_date|tojson }};

    const parseDateLabel = (label) => {
        if (typeof label !== 'string') {
            return null;
        }
        const parts = label.split('-').map((value) => Number.parseInt(value, 10));
        if (parts.length !== 3 || parts.some((value) => Number.isNaN(value))) {
            return null;
        }
        const [year, month, day] = parts;
        return new Date(Date.UTC(year, month - 1, day));
    };

    const isWeekendLabel = (label) => {
        const parsedDate = parseDateLabel(label);
        if (!parsedDate) {
            return false;
        }
        const dayOfWeek = parsedDate.getUTCDay();
        return dayOfWeek === 0 || dayOfWeek === 6;
    };

    const weekendBackgroundPlugin = {
        id: 'weekendBackground',
        beforeDraw(chart, _args, pluginOptions) {
            if (!pluginOptions || !pluginOptions.enabled) {
                return;
            }

            const xScale = chart.scales?.x;
            const chartArea = chart.chartArea;
            if (!xScale || !chartArea) {
                return;
            }

            const labels = chart.data?.labels || [];
            if (!labels.length) {
                return;
            }

            const weekendRanges = [];
            let currentRange = null;

            labels.forEach((label, index) => {
                if (isWeekendLabel(label)) {
                    if (!currentRange) {
                        currentRange = { start: index, end: index };
                    } else {
                        currentRange.end = index;
                    }
                } else if (currentRange) {
                    weekendRanges.push(currentRange);
                    currentRange = null;
                }
            });

            if (currentRange) {
                weekendRanges.push(currentRange);
            }

            if (!weekendRanges.length) {
                return;
            }

            const { ctx } = chart;
            const { left, right, top, bottom } = chartArea;

            const getCenterForIndex = (index) => {
                if (typeof xScale.getPixelForValue === 'function') {
                    try {
                        return xScale.getPixelForValue(labels[index], index);
                    } catch (error) {
                        // Fallback to tick-based calculation below
                    }
                }
                if (typeof xScale.getPixelForTick === 'function') {
                    return xScale.getPixelForTick(index);
                }
                return Number.NaN;
            };

            const getBoundary = (index, direction) => {
                if (labels.length === 1) {
                    return direction === 'left' ? left : right;
                }

                const center = getCenterForIndex(index);
                if (!Number.isFinite(center)) {
                    return direction === 'left' ? left : right;
                }

                if (direction === 'left') {
                    if (index === 0) {
                        const nextCenter = getCenterForIndex(1);
                        if (Number.isFinite(nextCenter)) {
                            return center - (nextCenter - center) / 2;
                        }
                        return left;
                    }
                    const previousCenter = getCenterForIndex(index - 1);
                    if (!Number.isFinite(previousCenter)) {
                        return left;
                    }
                    return center - (center - previousCenter) / 2;
                }

                if (index === labels.length - 1) {
                    const previousCenter = getCenterForIndex(index - 1);
                    if (Number.isFinite(previousCenter)) {
                        return center + (center - previousCenter) / 2;
                    }
                    return right;
                }

                const nextCenter = getCenterForIndex(index + 1);
                if (!Number.isFinite(nextCenter)) {
                    return right;
                }
                return center + (nextCenter - center) / 2;
            };

            ctx.save();
            ctx.fillStyle = pluginOptions.color || 'rgba(0, 0, 0, 0.08)';
            ctx.beginPath();
            ctx.rect(left, top, right - left, bottom - top);
            ctx.clip();

            weekendRanges.forEach((range) => {
                const rangeLeft = Math.max(left, getBoundary(range.start, 'left'));
                const rangeRight = Math.min(right, getBoundary(range.end, 'right'));

                if (!Number.isFinite(rangeLeft) || !Number.isFinite(rangeRight) || rangeRight <= rangeLeft) {
                    return;
                }

                ctx.fillRect(rangeLeft, top, rangeRight - rangeLeft, bottom - top);
            });

            ctx.restore();
        },
    };

    if (typeof Chart !== 'undefined') {
        Chart.register(weekendBackgroundPlugin);
    }

    if (chartLabels.length) {
        const stackedDatasetList = Array.isArray(stackedDatasets) ? stackedDatasets : [];
        const overlayDatasetList = Array.isArray(overlayDatasets) ? overlayDatasets : [];
        const lineDatasetList = Array.isArray(lineDatasets) ? lineDatasets : [];

        const deepCloneDataset = (dataset) => JSON.parse(JSON.stringify(dataset));
        const deepCloneDatasets = (datasets) => datasets.map((dataset) => deepCloneDataset(dataset));

        const originalLabels = chartLabels.slice();
        const originalCombinedDatasets = deepCloneDatasets(stackedDatasetList.concat(overlayDatasetList));
        const originalLineDatasets = deepCloneDatasets(lineDatasetList);
        const weekendMask = originalLabels.map((label) => isWeekendLabel(label));

        const cloneAndFilterDataset = (dataset, includeWeekends) => {
            const clonedDataset = deepCloneDataset(dataset);

            if (!includeWeekends && Array.isArray(dataset.data) && dataset.data.length === weekendMask.length) {
                clonedDataset.data = dataset.data.filter((_, index) => !weekendMask[index]);
            }

            if (!includeWeekends) {
                Object.keys(dataset).forEach((key) => {
                    if (key === 'data') {
                        return;
                    }
                    const value = dataset[key];
                    if (Array.isArray(value) && value.length === weekendMask.length) {
                        clonedDataset[key] = value.filter((_, index) => !weekendMask[index]);
                    }
                });
            }

            return clonedDataset;
        };

        const buildChartData = (includeWeekends) => {
            const labels = includeWeekends
                ? originalLabels.slice()
                : originalLabels.filter((_, index) => !weekendMask[index]);

            const combined = originalCombinedDatasets.map((dataset) => cloneAndFilterDataset(dataset, includeWeekends));
            const line = originalLineDatasets.map((dataset) => cloneAndFilterDataset(dataset, includeWeekends));

            return {
                labels,
                combinedDatasets: combined,
                lineDatasets: line,
            };
        };

        let currentIncludeWeekends = true;
        const collapseToggle = document.getElementById('collapseWeekendsToggle');
        if (collapseToggle) {
            collapseToggle.checked = !currentIncludeWeekends;
        }

        const createPrimaryScale = () => {
            const scale = {
                stacked: true,
                beginAtZero: chartAxisSettings.primary.min === null,
                title: {
                    display: true,
                    text: 'Units',
                },
            };

            if (chartAxisSettings.primary.min !== null) {
                scale.min = chartAxisSettings.primary.min;
            }
            if (chartAxisSettings.primary.max !== null) {
                scale.max = chartAxisSettings.primary.max;
            }
            if (chartAxisSettings.primary.step !== null) {
                scale.ticks = Object.assign({}, scale.ticks, {
                    stepSize: chartAxisSettings.primary.step,
                });
            }

            return scale;
        };

        const createSecondaryScale = () => {
            const scale = {
                position: 'right',
                beginAtZero: chartAxisSettings.secondary.min === null,
                grid: {
                    drawOnChartArea: false,
                },
                title: {
                    display: true,
                    text: 'Output per Labor Hour',
                },
            };

            if (chartAxisSettings.secondary.min !== null) {
                scale.min = chartAxisSettings.secondary.min;
            }
            if (chartAxisSettings.secondary.max !== null) {
                scale.max = chartAxisSettings.secondary.max;
            }
            if (chartAxisSettings.secondary.step !== null) {
                scale.ticks = Object.assign({}, scale.ticks, {
                    stepSize: chartAxisSettings.secondary.step,
                });
            }

            return scale;
        };

        const createBarChartConfig = (chartState, includeWeekends) => ({
            type: 'bar',
            data: {
                labels: chartState.labels,
                datasets: chartState.combinedDatasets,
            },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    weekendBackground: {
                        enabled: includeWeekends,
                        color: 'rgba(0, 0, 0, 0.08)',
                    },
                    title: {
                        display: true,
                        text: 'Gates Produced by Customer',
                    },
                    legend: {
                        position: 'bottom',
                    },
                },
                scales: {
                    x: {
                        stacked: true,
                    },
                    y: createPrimaryScale(),
                    'y-output': createSecondaryScale(),
                },
            },
        });

        const createLineChartConfig = (chartState, includeWeekends) => ({
            type: 'line',
            data: {
                labels: chartState.labels,
                datasets: chartState.lineDatasets,
            },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    weekendBackground: {
                        enabled: includeWeekends,
                        color: 'rgba(0, 0, 0, 0.08)',
                    },
                    title: {
                        display: true,
                        text: 'Cumulative Month-to-Date Totals',
                    },
                    legend: {
                        position: 'bottom',
                    },
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Units',
                        },
                    },
                },
            },
        });

        const initialState = buildChartData(currentIncludeWeekends);

        const barContext = document.getElementById('gatesProducedChart');
        let barChart = null;
        if (barContext) {
            barChart = new Chart(barContext, createBarChartConfig(initialState, currentIncludeWeekends));
        }

        const lineContext = document.getElementById('cumulativeChart');
        let lineChart = null;
        if (lineContext) {
            lineChart = new Chart(lineContext, createLineChartConfig(initialState, currentIncludeWeekends));
        }

        const emailModal = document.getElementById('emailDataModal');
        const emailButton = document.getElementById('emailDataButton');
        const emailDateSelect = document.getElementById('emailDataDateSelect');
        const emailNotesElement = document.getElementById('emailDataNotes');
        const emailBarCanvas = document.getElementById('emailBarChart');
        const emailLineCanvas = document.getElementById('emailLineChart');
        const emailDismissButtons = emailModal ? emailModal.querySelectorAll('[data-modal-dismiss]') : [];
        let emailBarChart = null;
        let emailLineChart = null;

        const emailModalIsOpen = () => emailModal && !emailModal.classList.contains('is-hidden');

        const updateEmailModalLabel = (dateLabel) => {
            if (!emailModal) {
                return;
            }
            if (dateLabel) {
                emailModal.setAttribute('aria-label', `Email-friendly production snapshot for ${dateLabel}`);
            } else {
                emailModal.setAttribute('aria-label', 'Email-friendly production snapshot');
            }
        };

        const renderEmailNotes = (dateLabel) => {
            if (!emailNotesElement) {
                updateEmailModalLabel(dateLabel);
                return;
            }

            const normalizedLabel = typeof dateLabel === 'string' ? dateLabel : '';
            const rawNotes = (notesByDate[normalizedLabel] || '').trim();
            if (rawNotes) {
                emailNotesElement.textContent = rawNotes;
                emailNotesElement.classList.remove('is-empty');
            } else {
                emailNotesElement.textContent = 'No notes recorded for this date.';
                emailNotesElement.classList.add('is-empty');
            }
            updateEmailModalLabel(normalizedLabel);
        };

        const destroyEmailCharts = () => {
            if (emailBarChart) {
                emailBarChart.destroy();
                emailBarChart = null;
            }
            if (emailLineChart) {
                emailLineChart.destroy();
                emailLineChart = null;
            }
        };

        const refreshEmailCharts = () => {
            if (!emailModalIsOpen()) {
                return;
            }
            const state = buildChartData(currentIncludeWeekends);
            if (emailBarCanvas) {
                const config = createBarChartConfig(state, currentIncludeWeekends);
                config.options = Object.assign({}, config.options, { maintainAspectRatio: false });
                if (emailBarChart) {
                    emailBarChart.destroy();
                }
                emailBarChart = new Chart(emailBarCanvas, config);
            }
            if (emailLineCanvas) {
                const config = createLineChartConfig(state, currentIncludeWeekends);
                config.options = Object.assign({}, config.options, { maintainAspectRatio: false });
                if (emailLineChart) {
                    emailLineChart.destroy();
                }
                emailLineChart = new Chart(emailLineCanvas, config);
            }
            if (emailDateSelect) {
                renderEmailNotes(emailDateSelect.value);
            }
        };

        const openEmailModal = () => {
            if (!emailModal || !chartLabels.length) {
                return;
            }
            emailModal.classList.remove('is-hidden');
            emailModal.setAttribute('aria-hidden', 'false');

            const latestLabel = chartLabels[chartLabels.length - 1] || '';
            if (emailDateSelect) {
                emailDateSelect.value = latestLabel;
            }
            renderEmailNotes(emailDateSelect ? emailDateSelect.value : latestLabel);

            window.requestAnimationFrame(() => {
                refreshEmailCharts();
            });
        };

        const closeEmailModal = () => {
            if (!emailModal) {
                return;
            }
            destroyEmailCharts();
            emailModal.classList.add('is-hidden');
            emailModal.setAttribute('aria-hidden', 'true');
            updateEmailModalLabel('');
        };

        const updateChartsForWeekendState = (includeWeekends) => {
            if (includeWeekends === currentIncludeWeekends) {
                return;
            }
            currentIncludeWeekends = includeWeekends;

            const updatedState = buildChartData(includeWeekends);

            if (barChart) {
                barChart.data.labels = updatedState.labels;
                barChart.data.datasets = updatedState.combinedDatasets;
                if (barChart.options?.plugins?.weekendBackground) {
                    barChart.options.plugins.weekendBackground.enabled = includeWeekends;
                }
                barChart.update();
            }

            if (lineChart) {
                lineChart.data.labels = updatedState.labels;
                lineChart.data.datasets = updatedState.lineDatasets;
                if (lineChart.options?.plugins?.weekendBackground) {
                    lineChart.options.plugins.weekendBackground.enabled = includeWeekends;
                }
                lineChart.update();
            }

            if (collapseToggle) {
                collapseToggle.checked = !includeWeekends;
            }

            refreshEmailCharts();
        };

        if (collapseToggle) {
            collapseToggle.addEventListener('change', (event) => {
                const includeWeekends = !event.target.checked;
                updateChartsForWeekendState(includeWeekends);
            });
        }

        if (emailButton) {
            emailButton.addEventListener('click', openEmailModal);
        }

        if (emailDateSelect) {
            emailDateSelect.addEventListener('change', (event) => {
                renderEmailNotes(event.target.value);
                refreshEmailCharts();
            });
        }

        if (emailModal) {
            emailModal.addEventListener('click', (event) => {
                if (event.target === emailModal) {
                    closeEmailModal();
                }
            });
        }

        emailDismissButtons.forEach((button) => {
            button.addEventListener('click', closeEmailModal);
        });

        const chartModal = document.getElementById('chartModal');
        const modalCanvas = document.getElementById('expandedChart');
        const chartDismissButtons = chartModal ? chartModal.querySelectorAll('[data-modal-dismiss]') : [];
        let modalChart = null;

        const cloneChartConfig = (chartInstance) => {
            const clonedData = JSON.parse(JSON.stringify(chartInstance.data));
            const clonedOptions = JSON.parse(JSON.stringify(chartInstance.options || {}));
            return {
                type: chartInstance.config.type,
                data: clonedData,
                options: Object.assign({}, clonedOptions, {
                    responsive: true,
                    maintainAspectRatio: false,
                }),
            };
        };

        const closeChartModal = () => {
            if (!chartModal) {
                return;
            }
            if (modalChart) {
                modalChart.destroy();
                modalChart = null;
            }
            chartModal.classList.add('is-hidden');
            chartModal.setAttribute('aria-label', 'Expanded chart view');
        };

        const openChartModal = (chartInstance) => {
            if (!chartModal || !modalCanvas || !chartInstance) {
                return;
            }

            chartModal.classList.remove('is-hidden');

            window.requestAnimationFrame(() => {
                const config = cloneChartConfig(chartInstance);
                if (modalChart) {
                    modalChart.destroy();
                    modalChart = null;
                }
                modalChart = new Chart(modalCanvas.getContext('2d'), config);
                const modalTitle = chartInstance.options?.plugins?.title?.text;
                if (modalTitle) {
                    chartModal.setAttribute('aria-label', `Expanded chart view: ${modalTitle}`);
                } else {
                    chartModal.setAttribute('aria-label', 'Expanded chart view');
                }
            });
        };

        if (chartModal) {
            chartModal.addEventListener('click', (event) => {
                if (event.target === chartModal) {
                    closeChartModal();
                }
            });
        }

        chartDismissButtons.forEach((button) => {
            button.addEventListener('click', closeChartModal);
        });

        document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') {
                return;
            }

            let handled = false;
            if (chartModal && !chartModal.classList.contains('is-hidden')) {
                closeChartModal();
                handled = true;
            }
            if (emailModal && !emailModal.classList.contains('is-hidden')) {
                closeEmailModal();
                handled = true;
            }

            if (handled) {
                event.preventDefault();
            }
        });

        const registerChartForExpansion = (canvasElement, chartInstance) => {
            if (!canvasElement || !chartInstance) {
                return;
            }

            canvasElement.classList.add('chart-expandable');
            canvasElement.setAttribute('tabindex', '0');
            canvasElement.setAttribute('role', 'button');

            const originalLabel = canvasElement.getAttribute('aria-label') || 'Chart';
            if (!originalLabel.toLowerCase().includes('click to expand')) {
                canvasElement.setAttribute('aria-label', `${originalLabel} (click to expand)`);
            }

            canvasElement.addEventListener('click', () => {
                openChartModal(chartInstance);
            });

            canvasElement.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    openChartModal(chartInstance);
                }
            });
        };

        registerChartForExpansion(barContext, barChart);
        registerChartForExpansion(lineContext, lineChart);
    }
</script>
{% endblock %}
